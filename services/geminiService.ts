
import { GoogleGenAI, Type, Schema } from "@google/genai";
import { 
  GameDetails, 
  AiResponse, 
  AiMetadata,
  AdCreative, 
  CopyVariant,
  CpeEvent,
  CompetitorReport,
  CompetitorMetrics,
  TargetAudience,
  MarketPerformance,
  StoreComparisonResponse,
  PushStrategyResponse,
  LiveOpsContent,
  VideoAnalysisResponse,
  FourElementsScore,
  SkinnerBoxResponse,
  DopamineLoopResponse,
  BartleResponse,
  NarrativeResponse,
  MarketingCalendarData,
  EconomicMetrics
} from "../types";

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

// --- Helper Functions ---

const createMeta = (model: string, prompt: string, response?: any): AiMetadata => ({
  model,
  prompt,
  reasoning: "Generated by Gemini",
  sources: response?.candidates?.[0]?.groundingMetadata?.groundingChunks?.map((chunk: any) => ({
    title: chunk.web?.title || "Source",
    url: chunk.web?.uri || ""
  })).filter((s: any) => s.url) || []
});

const generateText = async (prompt: string, model: string = 'gemini-3-pro-preview', useSearch: boolean = false) => {
  const config: any = {};
  if (useSearch) {
    config.tools = [{ googleSearch: {} }];
  }
  const response = await ai.models.generateContent({
    model,
    contents: prompt,
    config
  });
  return { text: response.text || "", meta: createMeta(model, prompt, response) };
};

const generateJson = async <T>(prompt: string, model: string = 'gemini-3-pro-preview', schemaType?: Schema): Promise<AiResponse<T>> => {
  const config: any = {
    responseMimeType: "application/json",
  };
  if (schemaType) {
    config.responseSchema = schemaType;
  }
  
  const response = await ai.models.generateContent({
    model,
    contents: prompt,
    config
  });
  
  let data: T;
  try {
    data = JSON.parse(response.text || "{}");
  } catch (e) {
    console.error("Failed to parse JSON", e);
    data = {} as T;
  }

  return {
    data,
    meta: createMeta(model, prompt, response)
  };
};

// --- Exported Service Functions ---

export const createChatSession = (model: string, systemInstruction?: string) => {
  return ai.chats.create({
    model: model,
    config: { systemInstruction }
  });
};

export const generateMarketingPlan = async (details: GameDetails, platform: string, language: string, model: string) => {
  const prompt = `Create a marketing strategy for a game. Platform: ${platform}. Language: ${language}.
  Game Details: ${JSON.stringify(details)}.
  Include: Campaign Structure, Targeting, Creative Strategy, Budget Allocation.`;
  
  const { text, meta } = await generateText(prompt, model);
  return { data: text, meta };
};

export const generateAsoAnalysis = async (details: GameDetails, language: string, model: string) => {
  const prompt = `Conduct an ASO keyword analysis for the game "${details.name}" (${details.genre}).
  Market: ${details.market}. Language: ${language}.
  Suggest keywords, title optimization, and description improvements.`;
  
  const { text, meta } = await generateText(prompt, model);
  return { data: text, meta };
};

export const generateDeepAsoAnalysis = async (gameName: string, genre: string, storeUrl: string, competitors: string, market: string) => {
  const prompt = `Perform a deep ASO analysis for "${gameName}". Genre: ${genre}. URL: ${storeUrl}.
  Competitors: ${competitors}. Target Market: ${market}.
  Analyze metadata, suggest high-volume/low-competition keywords, and provide conversion optimization tips.`;
  
  const { text } = await generateText(prompt, 'gemini-3-pro-preview', true);
  return text;
};

export const extractGameNameFromUrl = async (url: string) => {
  const prompt = `Extract the game name from this URL: ${url}. Return only the name.`;
  const { text } = await generateText(prompt, 'gemini-2.5-flash');
  return text.trim();
};

export const generateAdCopy = async (details: GameDetails, concept: string, cta: string, language: string, model: string) => {
  const prompt = `Write a Facebook ad copy for mobile game "${details.name}".
  Concept: ${concept}. CTA: ${cta}. Language: ${language}.
  Return JSON with fields: headline, body, cta.`;
  
  const response = await generateJson<{ headline: string, body: string, cta: string }>(prompt, model);
  return response.data;
};

export const generateFacebookAdCopies = async (
  productName: string, 
  description: string, 
  language: string, 
  includeEmojis: boolean, 
  storeUrl: string, 
  style: string, 
  model: string
): Promise<CopyVariant[]> => {
  const prompt = `Generate 5 Facebook ad copy variants for game "${productName}".
  Description: ${description}. Language: ${language}. Style: ${style}. Emojis: ${includeEmojis}.
  Return a JSON array of objects with 'id' (string), 'sourceText' (English rationale), 'targetText' (Final copy).`;
  
  const schema: Schema = {
    type: Type.ARRAY,
    items: {
      type: Type.OBJECT,
      properties: {
        id: { type: Type.STRING },
        sourceText: { type: Type.STRING },
        targetText: { type: Type.STRING }
      },
      required: ["id", "sourceText", "targetText"]
    }
  };

  const response = await generateJson<CopyVariant[]>(prompt, model, schema);
  return response.data || [];
};

export const generateAdImage = async (
  prompt: string, 
  ratio: string, 
  style: string, 
  visualDetails: string, 
  language: string, 
  includeText: boolean, 
  includeCharacters: boolean,
  model: string = 'gemini-2.5-flash-image'
) => {
  let fullPrompt = `${prompt}. Style: ${style}. ${visualDetails}. Language: ${language}.`;
  if (includeText) fullPrompt += " Include relevant text/headlines.";
  if (includeCharacters) fullPrompt += " Include main characters.";
  
  // Map Aspect Ratio strings to what API expects if needed, generally Gemini API expects "1:1", "16:9" etc.
  
  if (model.includes('imagen')) {
    const response = await ai.models.generateImages({
        model: 'imagen-3.0-generate-002',
        prompt: fullPrompt,
        config: {
            numberOfImages: 1,
            aspectRatio: ratio as any // Imagen supports these strings
        }
    });
    const b64 = response.generatedImages[0].image.imageBytes;
    return { imageUrl: `data:image/png;base64,${b64}`, prompt: fullPrompt, promptZh: "" };
  } else {
    // gemini model
    const response = await ai.models.generateContent({
        model: model,
        contents: { parts: [{ text: fullPrompt }] },
        config: {
            imageConfig: { aspectRatio: ratio as any }
        }
    });
    
    let imageUrl = "";
    if (response.candidates?.[0]?.content?.parts) {
        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData) {
                imageUrl = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
                break;
            }
        }
    }
    return { imageUrl, prompt: fullPrompt, promptZh: "" };
  }
};

export const generateCompositeImage = async (images: { label: string, data: string, mimeType: string }[], prompt: string, ratio: string, style: string, model: string) => {
  const parts = images.map(img => ({
      inlineData: { data: img.data, mimeType: img.mimeType }
  }));
  const textPart = { text: `Create a composite image based on these inputs. ${prompt}. Ratio: ${ratio}. Style: ${style}.` };
  
  let validRatio = ratio;
  if (ratio === '4:5') validRatio = '3:4'; 
  const supportedRatios = ["1:1", "3:4", "4:3", "9:16", "16:9"];
  if (!supportedRatios.includes(validRatio)) {
      validRatio = "1:1";
  }

  let effectiveModel = model;
  if (model.includes('imagen')) {
      // Imagen doesn't support multi-modal input in generateImages easily via this SDK in one go for composition the same way Gemini does with parts
      // Fallback to Gemini for composition
      effectiveModel = 'gemini-3-pro-image-preview'; 
  }

  const response = await ai.models.generateContent({
      model: effectiveModel,
      contents: { parts: [...parts, textPart] },
      config: {
          imageConfig: { aspectRatio: validRatio as any }
      }
  });

  let imageUrl = "";
  if (response.candidates?.[0]?.content?.parts) {
      for (const part of response.candidates[0].content.parts) {
          if (part.inlineData) {
              imageUrl = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
              break;
          }
      }
  }
  return { imageUrl, prompt: prompt };
};

export const analyzeVisualDetailsFromUrl = async (gameName: string, url: string) => {
  const prompt = `Analyze the visual style of ${gameName} from its store page: ${url}. Return a short paragraph describing art style, color palette, and key visual elements.`;
  const { text } = await generateText(prompt, 'gemini-2.5-flash', true);
  return text;
};

export const generateAppIcon = async (gameName: string, genre: string, style: string, elements: string) => {
  const prompt = `App Icon for ${gameName} (${genre}). Style: ${style}. Elements: ${elements}. High quality, 512x512 format.`;
  const result = await generateAdImage(prompt, '1:1', style, '', 'English', false, false, 'gemini-2.5-flash-image');
  return result.imageUrl;
};

export const analyzeIconElementsFromUrl = async (gameName: string, url: string) => {
  const prompt = `Analyze the icon of ${gameName} at ${url}. Describe the key elements, colors, and style used in the icon.`;
  const { text } = await generateText(prompt, 'gemini-2.5-flash', true);
  return text;
};

export const analyzeSellingPointsFromUrl = async (productName: string, url: string) => {
  const prompt = `Analyze the selling points of ${productName} from ${url}. Summarize core features and USP in Simplified Chinese.`;
  const { text } = await generateText(prompt, 'gemini-2.5-flash', true);
  return text;
};

export const generateCpeEvents = async (
  gameName: string, 
  genre: string, 
  gameplay: string, 
  goal: string, 
  singleCount: number, 
  comboCount: number,
  model: string
): Promise<AiResponse<{ singleEvents: CpeEvent[], comboEvents: CpeEvent[] }>> => {
  const prompt = `Generate CPE (Cost Per Engagement) events for game "${gameName}" (${genre}).
  Gameplay: ${gameplay}. UA Goal: ${goal}.
  Generate ${singleCount} single events and ${comboCount} combo events.
  Return JSON with 'singleEvents' and 'comboEvents' arrays. Each event has: id, eventName, difficulty, estimatedTime, descriptionZh, descriptionEn, completionRate, timeLimit, uaValueZh, uaValueEn.`;
  
  const schema: Schema = {
    type: Type.OBJECT,
    properties: {
      singleEvents: { type: Type.ARRAY, items: { type: Type.OBJECT, properties: {
        id: { type: Type.STRING },
        eventName: { type: Type.STRING },
        difficulty: { type: Type.STRING },
        estimatedTime: { type: Type.STRING },
        descriptionZh: { type: Type.STRING },
        descriptionEn: { type: Type.STRING },
        completionRate: { type: Type.STRING },
        timeLimit: { type: Type.STRING },
        uaValueZh: { type: Type.STRING },
        uaValueEn: { type: Type.STRING }
      }}},
      comboEvents: { type: Type.ARRAY, items: { type: Type.OBJECT, properties: {
        id: { type: Type.STRING },
        eventName: { type: Type.STRING },
        difficulty: { type: Type.STRING },
        estimatedTime: { type: Type.STRING },
        descriptionZh: { type: Type.STRING },
        descriptionEn: { type: Type.STRING },
        completionRate: { type: Type.STRING },
        timeLimit: { type: Type.STRING },
        uaValueZh: { type: Type.STRING },
        uaValueEn: { type: Type.STRING }
      }}}
    }
  };

  return generateJson(prompt, model, schema);
};

export const analyzeGameplayFromUrl = async (gameName: string, url: string) => {
  const prompt = `Analyze gameplay of ${gameName} from ${url}. Describe core loop, mechanics, and controls.`;
  const { text } = await generateText(prompt, 'gemini-2.5-flash', true);
  return text;
};

export const generateAsmrPlan = async (gameName: string, genre: string, type: string, url: string, language: string) => {
  const prompt = `Create an ASMR marketing plan for ${gameName} (${genre}). Type: ${type}. URL: ${url}. Language: ${language}.
  Analyze sound potential and suggest creative video concepts.`;
  const { text } = await generateText(prompt, 'gemini-3-pro-preview', true);
  return text;
};

export const generateAbacrAnalysis = async (gameName: string, genre: string, gameplay: string, url: string, purpose: string, language: string) => {
  const prompt = `Analyze ${gameName} using ABACR level design model. Genre: ${genre}. Gameplay: ${gameplay}. URL: ${url}. Design Purpose: ${purpose}. Language: ${language}.`;
  const { text } = await generateText(prompt, 'gemini-3-pro-preview', true);
  return text;
};

export const expandDesignPurpose = async (input: string, gameName: string) => {
  const prompt = `Expand this design purpose for game ${gameName}: "${input}". Make it more specific and professional.`;
  const { text } = await generateText(prompt, 'gemini-2.5-flash');
  return text;
};

export const analyzeGameEconomics = async (metrics: EconomicMetrics, countries: string) => {
  const prompt = `Analyze the game economics based on these metrics: ${JSON.stringify(metrics)}. Target Countries: ${countries}.
  Provide insights on LTV, ROAS, and suggestions for improvement. Language: Simplified Chinese.`;
  const { text } = await generateText(prompt, 'gemini-3-pro-preview');
  return text;
};

export const analyzeCompetitor = async (gameName: string, url: string, language: string, model: string, dimensions?: string[]) => {
  const dimStr = dimensions ? `Focus on these dimensions: ${dimensions.join(', ')}.` : '';
  const prompt = `Analyze competitor "${gameName}" (${url}). ${dimStr} Language: ${language}.
  Return JSON with:
  - report: { marketAnalysis, productAnalysis, coreGameplay, abacrAnalysis, hookedModel, emotionalAttachment, pushStrategy, asmrPotential, monetization, liveOps, gameEvents, branding, community, ipPotential, techStack, localization, userReviews, swot }
  - metrics: { d1, d7, d30, avgSessionDuration, estimatedDau, topCountries }
  - audience: { age, gender, countries, occupation, income, interests, relationship }
  - market: { financialTrends, rankingHistory, genderDistribution, ageDistribution }
  `;
  
  // Note: Schema definition is complex here, for brevity we rely on the model's instruction following or define simplified schema if strictly needed.
  // Using 'any' for the generic type to allow flexible return, but ideally should match CompetitorReport structure.
  return generateJson<any>(prompt, model);
};

export const compareStorePages = async (url1: string, url2: string, language: string, model: string) => {
  const prompt = `Compare two mobile game store pages: ${url1} and ${url2}. Language: ${language}.
  Return JSON with:
  - game1Name, game2Name
  - comparisonTable: Array of { dimension, game1Content, game2Content, winner, insight }
  - detailedAnalysis: string`;
  
  return generateJson<StoreComparisonResponse>(prompt, model);
};

export const generatePushStrategy = async (
  gameName: string, genre: string, tone: string, language: string, url: string, emojis: boolean, count: number, timing: boolean, triggers: string[], model: string
) => {
  const prompt = `Create a push notification strategy for ${gameName} (${genre}). URL: ${url}.
  Tone: ${tone}. Language: ${language}. Emojis: ${emojis}. Count per category: ${count}. Include Timing: ${timing}.
  Triggers: ${triggers.join(', ')}.
  Return JSON array of sections, each with category and notifications array (title, body, emoji, translation, timing, triggerCondition).`;
  
  return generateJson<PushStrategyResponse>(prompt, model);
};

export const generateLiveOpsContent = async (
  gameName: string, url: string, type: string, theme: string, language: string, text: boolean, chars: boolean, model: string
) => {
  const prompt = `Generate LiveOps content for ${gameName} (${url}). Event: ${type}. Theme: ${theme}. Language: ${language}.
  Return JSON with: eventName, shortDescription, longDescription, imagePrompt (for AI generation), translation (object with same fields).`;
  
  return generateJson<LiveOpsContent>(prompt, model);
};

export const generateHookedAnalysis = async (gameName: string, gameplay: string, url: string, audience: string, language: string, model: string) => {
  const prompt = `Analyze ${gameName} using the Hooked Model (Trigger, Action, Reward, Investment).
  Gameplay: ${gameplay}. URL: ${url}. Target Audience: ${audience}. Language: ${language}.`;
  
  const { text, meta } = await generateText(prompt, model, true);
  return { data: text, meta };
};

export const generateMdaAnalysis = async (gameName: string, genre: string, gameplay: string, url: string, language: string) => {
  const prompt = `Analyze ${gameName} using MDA Framework (Mechanics, Dynamics, Aesthetics).
  Genre: ${genre}. Gameplay: ${gameplay}. URL: ${url}. Language: ${language}.`;
  
  const { text } = await generateText(prompt, 'gemini-3-pro-preview', true);
  return text;
};

export const generateOctalysisAnalysis = async (gameName: string, gameplay: string, url: string, audience: string, language: string) => {
  const prompt = `Analyze ${gameName} using Octalysis Framework (8 Core Drives).
  Gameplay: ${gameplay}. URL: ${url}. Audience: ${audience}. Language: ${language}.`;
  
  const { text } = await generateText(prompt, 'gemini-3-pro-preview', true);
  return text;
};

export const generateFoggBehaviorAnalysis = async (gameName: string, gameplay: string, url: string, audience: string, language: string) => {
  const prompt = `Analyze ${gameName} using Fogg Behavior Model (B=MAP).
  Gameplay: ${gameplay}. URL: ${url}. Audience: ${audience}. Language: ${language}.`;
  
  const { text } = await generateText(prompt, 'gemini-3-pro-preview', true);
  return text;
};

export const generateFlowAnalysis = async (gameName: string, gameplay: string, url: string, skill: string, language: string) => {
  const prompt = `Analyze ${gameName} using Flow Theory. Player Skill: ${skill}.
  Gameplay: ${gameplay}. URL: ${url}. Language: ${language}.`;
  
  const { text } = await generateText(prompt, 'gemini-3-pro-preview', true);
  return text;
};

export const generateFourElementsAnalysis = async (gameName: string, gameplay: string, url: string, genre: string, language: string) => {
  const prompt = `Analyze ${gameName} using Caillois' Four Elements (Agon, Alea, Mimicry, Ilinx).
  Gameplay: ${gameplay}. URL: ${url}. Genre: ${genre}. Language: ${language}.
  Return JSON with 'scores' (agon, alea, mimicry, ilinx as numbers 0-10) and 'analysis' (string).`;
  
  return generateJson<{ scores: FourElementsScore, analysis: string }>(prompt, 'gemini-3-pro-preview');
};

export const generateSkinnerBoxAnalysis = async (gameName: string, gameplay: string, url: string, language: string) => {
  const prompt = `Analyze ${gameName} using Skinner Box / Operant Conditioning concepts.
  Gameplay: ${gameplay}. URL: ${url}. Language: ${language}.
  Return JSON with 'analysis' (string) and 'schedules' ({ fixedRatio, variableRatio, fixedInterval, variableInterval } - strings).`;
  
  return generateJson<SkinnerBoxResponse>(prompt, 'gemini-3-pro-preview');
};

export const generateDopamineLoopAnalysis = async (gameName: string, gameplay: string, url: string, rewards: string, language: string) => {
  const prompt = `Analyze the Dopamine Loop in ${gameName}. Rewards: ${rewards}.
  Gameplay: ${gameplay}. URL: ${url}. Language: ${language}.
  Return JSON with 'analysis' (string) and 'loop' ({ goal, reward, feedback }).`;
  
  return generateJson<DopamineLoopResponse>(prompt, 'gemini-3-pro-preview');
};

export const generateBartleAnalysis = async (gameName: string, gameplay: string, url: string, language: string) => {
  const prompt = `Analyze ${gameName} for Bartle Player Types.
  Gameplay: ${gameplay}. URL: ${url}. Language: ${language}.
  Return JSON with 'analysis' (string) and 'scores' ({ achievers, explorers, socializers, killers } - numbers 0-100).`;
  
  return generateJson<BartleResponse>(prompt, 'gemini-3-pro-preview');
};

export const generateNarrativeAnalysis = async (gameName: string, gameplay: string, url: string, genre: string, language: string) => {
  const prompt = `Analyze Narrative Design of ${gameName}.
  Gameplay: ${gameplay}. URL: ${url}. Genre: ${genre}. Language: ${language}.
  Return JSON with 'analysis' (string) and 'scores' ({ threeAct, nonLinear, circular, interactive } - numbers 0-10).`;
  
  return generateJson<NarrativeResponse>(prompt, 'gemini-3-pro-preview');
};

export const generateIaaPlan = async (gameName: string, genre: string, gameplay: string, market: string, language: string) => {
  const prompt = `Create an In-App Advertising (IAA) strategy for ${gameName} (${genre}).
  Gameplay: ${gameplay}. Market: ${market}. Language: ${language}.
  Include ad formats, placement suggestions, and frequency capping.`;
  const { text } = await generateText(prompt, 'gemini-3-pro-preview');
  return text;
};

export const generateIapPlan = async (gameName: string, genre: string, gameplay: string, audience: string, language: string) => {
  const prompt = `Create an In-App Purchase (IAP) strategy for ${gameName} (${genre}).
  Gameplay: ${gameplay}. Audience: ${audience}. Language: ${language}.
  Include pricing strategy, bundle ideas, and monetization mechanics.`;
  const { text } = await generateText(prompt, 'gemini-3-pro-preview');
  return text;
};

export const generateGooglePlayNews = async (language: string) => {
  const prompt = `Summarize the latest Google Play news, policy updates, and trends from the last 30 days. Language: ${language}.`;
  const { text, meta } = await generateText(prompt, 'gemini-3-pro-preview', true); // Use search
  return { data: text, meta };
};

export const generateAppStoreNews = async (language: string) => {
  const prompt = `Summarize the latest Apple App Store news, policy updates, and trends from the last 30 days. Language: ${language}.`;
  const { text } = await generateText(prompt, 'gemini-3-pro-preview', true);
  return text;
};

export const generateAdTechNews = async (platform: string, language: string) => {
  const prompt = `Summarize the latest news and updates for ${platform} advertising platform from the last 30 days. Language: ${language}.`;
  const { text } = await generateText(prompt, 'gemini-3-pro-preview', true);
  return text;
};

export const generateMarketingCalendar = async (countries: string, year: number, quarter: string, language: string, model: string) => {
  const prompt = `Create a marketing calendar for ${countries}. Year: ${year}, Quarter: ${quarter}. Language: ${language}.
  Return JSON with:
  - markdown: String containing the detailed calendar.
  - chartData: Array of { month, keyEvent, intensity, historicalRoas, historicalCtr, pastCampaignInsight }.`;
  
  return generateJson<{ markdown: string, chartData: MarketingCalendarData[] }>(prompt, model);
};

export const generateAdBiddingStrategy = async (gameName: string, genre: string, platform: string, market: string, language: string) => {
  const prompt = `Create an Ad Bidding strategy for ${gameName} (${genre}) on ${platform} in ${market}. Language: ${language}.
  Include suggestions for waterfall vs bidding, floor prices, and network mix.`;
  const { text } = await generateText(prompt, 'gemini-3-pro-preview');
  return text;
};

export const generateIapPricingStrategy = async (gameName: string, genre: string, region: string, language: string) => {
  const prompt = `Create an IAP pricing portfolio for ${gameName} (${genre}) in ${region}. Language: ${language}.
  Suggest specific price points (SKUs), bundles, and psychological pricing tactics.`;
  const { text } = await generateText(prompt, 'gemini-3-pro-preview');
  return text;
};

export const generateAiNews = async (timeRange: string, language: string) => {
  const prompt = `Summarize the latest AI news (Gemini, ChatGPT, etc.) for ${timeRange}. Language: ${language}.`;
  const { text } = await generateText(prompt, 'gemini-3-pro-preview', true);
  return text;
};

export const generateOmnichannelStrategy = async (details: GameDetails, gpUrl: string, iosUrl: string, language: string, model: string) => {
  const prompt = `Create an Omnichannel Marketing Strategy for ${details.name}.
  Google Play: ${gpUrl}. App Store: ${iosUrl}.
  Details: ${JSON.stringify(details)}. Language: ${language}.
  Include UA channels, ASO, creative strategy, and budget split.`;
  
  const { text, meta } = await generateText(prompt, model, true);
  return { data: text, meta };
};

export const describeImageForRecreation = async (base64: string, mimeType: string, model: string) => {
  const response = await ai.models.generateContent({
    model: model,
    contents: {
      parts: [
        { inlineData: { data: base64, mimeType } },
        { text: "Describe this image in detail so it can be recreated by an AI image generator. Include style, composition, colors, and key elements." }
      ]
    }
  });
  return response.text || "";
};

export const generatePersonalizationStrategy = async (
  gameName: string, genre: string, url: string, monetization: string, segments: string, focus: string, language: string, model: string
) => {
  const prompt = `Create a Personalization & AB Testing Strategy for ${gameName} (${genre}). URL: ${url}.
  Monetization: ${monetization}. Segments: ${segments}. Focus: ${focus}. Language: ${language}.`;
  
  const { text, meta } = await generateText(prompt, model, true);
  return { data: text, meta };
};

export const analyzeVideoFrames = async (frames: string[], context: string, scriptLang: string, storyboardLang: string, promptLang: string, model: string) => {
  const parts: any[] = frames.map(f => ({ inlineData: { data: f, mimeType: 'image/jpeg' } }));
  parts.push({ text: `Analyze these video frames. Context: ${context}.
  Output Script Language: ${scriptLang}.
  Output Storyboard Description Language: ${storyboardLang}.
  Output Image Prompt Language: ${promptLang}.
  Return JSON with:
  - script: string (The video script/narrative)
  - storyboard: Array of { id, shotNumber, description, audio, visualPrompt }` });

  // Add schema for strict JSON
  const schema: Schema = {
    type: Type.OBJECT,
    properties: {
        script: { type: Type.STRING },
        storyboard: { 
            type: Type.ARRAY, 
            items: { 
                type: Type.OBJECT, 
                properties: {
                    id: { type: Type.STRING },
                    shotNumber: { type: Type.NUMBER },
                    description: { type: Type.STRING },
                    audio: { type: Type.STRING },
                    visualPrompt: { type: Type.STRING }
                }
            } 
        }
    }
  };

  const config = {
      responseMimeType: "application/json",
      responseSchema: schema
  };

  const response = await ai.models.generateContent({
    model,
    contents: { parts },
    config
  });

  let data: VideoAnalysisResponse;
  try {
      data = JSON.parse(response.text || "{}");
      // Ensure IDs are strings if model returns numbers or missing
      if (data.storyboard) {
          data.storyboard = data.storyboard.map((s, i) => ({
              ...s,
              id: s.id || `shot-${i}`,
              shotNumber: s.shotNumber || i + 1
          }));
      }
  } catch(e) {
      data = { script: "", storyboard: [] };
  }

  return { data, meta: createMeta(model, "Video Frame Analysis", response) };
};

export const analyzeVideoUrl = async (videoUrl: string, context: string, scriptLang: string, storyboardLang: string, promptLang: string, model: string) => {
  // Since we cannot fetch video bytes directly from URL easily in client-side without proxy/CORS, 
  // we use Google Search grounding to "watch" or find info about the video if it's public (like YouTube).
  const prompt = `Analyze the video at ${videoUrl}. Context: ${context}.
  Output Script Language: ${scriptLang}.
  Output Storyboard Description Language: ${storyboardLang}.
  Output Image Prompt Language: ${promptLang}.
  Return JSON with:
  - script: string
  - storyboard: Array of { id, shotNumber, description, audio, visualPrompt }`;

  return generateJson<VideoAnalysisResponse>(prompt, model); // Will likely use internal knowledge or search if enabled
};

export const generateVideoFromImage = async (prompt: string, imageUrl: string, model: string) => {
    // imageUrl is data url, need to strip header
    const base64 = imageUrl.split(',')[1];
    const mimeType = imageUrl.substring(imageUrl.indexOf(':') + 1, imageUrl.indexOf(';'));
    
    let operation = await ai.models.generateVideos({
      model: model,
      prompt: prompt,
      image: {
        imageBytes: base64,
        mimeType: mimeType,
      },
      config: { 
        numberOfVideos: 1,
        resolution: '720p',
        aspectRatio: '16:9'
      }
    });
    
    while (!operation.done) {
      await new Promise(resolve => setTimeout(resolve, 5000));
      operation = await ai.operations.getVideosOperation({operation: operation});
    }
    
    const downloadLink = operation.response?.generatedVideos?.[0]?.video?.uri;
    if (!downloadLink) throw new Error("Video generation failed");
    
    return `${downloadLink}&key=${process.env.API_KEY}`;
};

export const generatePlayableConcept = async (gameName: string, input: string, language: string, model: string) => {
  const prompt = `Create a Playable Ad concept document for ${gameName}. Input/Context: ${input}. Language: ${language}.
  Include: Core Gameplay Loop, User Flow, Interaction Logic, and Technical Specs.`;
  const { text, meta } = await generateText(prompt, model);
  return { data: text, meta };
};

export const generatePlayableCode = async (concept: string, model: string) => {
  const prompt = `Generate a single HTML5 file for a playable ad based on this concept: ${concept}.
  Use inline CSS and JS. Use a simple 2D canvas approach or DOM elements. No external assets (use placeholders).
  Ensure it handles clicks and has a 'Call to Action' end screen.`;
  const { text } = await generateText(prompt, model);
  // Extract code block if present
  const codeBlock = text.match(/```html([\s\S]*?)```/);
  return codeBlock ? codeBlock[1] : text;
};

export const analyzeJson = async (jsonInput: string, context: string, model: string, language: string) => {
  const prompt = `Analyze this JSON code. Context: ${context}. Language: ${language}.
  1. Validate syntax and structure.
  2. Explain what it does.
  3. Generate a Mermaid JS flowchart code representing the logic/structure.
  JSON: ${jsonInput}`;
  
  const { text, meta } = await generateText(prompt, model);
  return { data: text, meta };
};
